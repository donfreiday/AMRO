ifelse(
point.count[, 2] == "Fox_Den_y7_2",
"y7",
ifelse(
point.count[, 2] == "Fox_Den_y5_1",
"y5",
ifelse(
point.count[, 2] == "Fox_Den_y5_2",
"y5",
ifelse(
point.count[, 2] == "Fox_Den_y5_3",
"y5",
ifelse(
point.count[, 2] == "Fox_Den_y3_1",
"y3",
ifelse(
point.count[, 2] == "Fox_Den_y3_2",
"y3",
ifelse(
point.count[, 2] == "Fox_Den_y3_3",
"y3",
ifelse(
point.count[, 2] == "Fox_Den_y3_4",
"y3",
ifelse(
point.count[, 2] == "Mowed_y0_3",
"y0",
ifelse(
point.count[, 2] == "Mowed_y0_4",
"y0",
ifelse(
point.count[, 2] == "Fox_Den_y0_1",
"y0",
ifelse(
point.count[, 2] == "Forest_Interior_1",
"mature",
ifelse(
point.count[, 2] == "Forest_Interior_2",
"mature",
ifelse(
point.count[, 2] == "Forest_Interior_3",
"mature",
ifelse(
point.count[, 2] == "Forest_Edge_1",
"edge",
ifelse(
point.count[, 2] == "Forest_Edge_2",
"edge",
ifelse(point.count[, 2] == "Forest_Edge_3", "edge",
NA  )))))))))))))))))))))))))))
# Note for Don: str(foo) displays a compact form of the object
str(point.count)
# Create a column with month data
point.count$date.char <- as.character(point.count$DATE)
point.count$date.char.sub <- substr(point.count$date.char, 0, 2)
point.count$month <- ifelse(
point.count$date.char.sub == "9/",
"September",
ifelse(
point.count$date.char.sub == "10",
"October",
ifelse(point.count$date.char.sub == "11", "November",
NA)
)
)
point.count$date.char <- NULL
point.count$date.char.sub <- NULL
View(point.count)
# Combine all 0-11 m and 11-25m observations to make a better half normal function and even distance breaks
point.count$dist.band.num <- ifelse(point.count$Distance.Band == "0-10 m", "1",
ifelse(point.count$Distance.Band == "11-25 m", "1",
ifelse(point.count$Distance.Band == "25-50 m", "2",
ifelse(point.count$Distance.Band == ">50 m", "3",
ifelse(point.count$Distance.Band == "FO", "4",
NA)))))
# Create another column with month and category as a unique identifier
point.count$block_id <- paste(point.count$category, point.count$month, sep='_')
# create one more category to identify unique surveys
point.count$survey_id <- paste(point.count$Point.Name, point.count$DATE, sep='_')
# Make a data frame with the covariates and de-duplicate
det.covs <- point.count[,c(4:8,23:25,27:28)]
det.covs.dd = det.covs[!duplicated(det.covs), ]
# Make a data frame with the covariates and de-duplicate
det.covs <- point.count[,c(4:8,23:25,27:28)]
det.covs <- det.covs[!duplicated(det.covs), ]
rm(det.covs.dd)
#melt count data
data.count.melt <- melt(point.count, id=c("survey_id", "dist.band.num","block_id","month","category","age","Distance.Band","Species.Code","Point.Name","DATE"), measure=c("Total.Count"), na.rm=FALSE)
###Cast count data using the sum of all sparrows seen
# todo: Use species variable instead of string literal
count.data <- dcast(data.count.melt, survey_id ~ dist.band.num, fun.aggregate=sum, subset = .((Species.Code == "AMRO" ))) # | (Species.Code=="AMRO" ) | (Species.Code=="VEER") | (Species.Code=="SWTH") | (Species.Code=="WOTH") | (Species.Code=="EABL"))) # | (Species.Code=="SAVS") | (Species.Code=="SWSP") | (Species.Code=="FOSP")))
# Remove all variables from the environment. ls() lists variables, rm() removes variables.
# This won't remove variables beginning with '.', use rm(list = ls(all.names = TRUE)) for that.
rm(list = ls(all.names = TRUE))
# Missing packages can be installed using install.packages("<package>") in the R Console.
library(unmarked)
library(reshape2)
library(ggplot2)
setwd("~/projects/AMRO")
# Analysis will be performed on each of these species codes via for loop
species.codes <- c("AMRO", "EABL", "SAVS", "SWSP", "FOSP");
# This for loop is an example for Tim
for(species in species.codes) {
cat(species, "\n")
}
# This function is an example for Tim
println <- function(string) {
cat(string, "\n")
}
println(species)
point.count <- read.csv('PC_DATA_16.csv', header=TRUE)
# Get rid of surveys from points with no planting or no maintenance due to not enough survey points
# Note for Don: in R, & is a vectorized operator. &&  form evaluates left to right examining only the first element of each vector.
point.count <- subset(point.count, point.count[,2] != "Maintenance_No_Planting"  & point.count[,2] != "No_Planting_No_Maintenance", drop=T)
# Create a column for age value and fill it
point.count$age <-
ifelse(point.count[, 2] == "Original_y25_1", 25,
ifelse(point.count[, 2] == "Original_y25_2", 25,
ifelse(point.count[, 2] == "Original_y25_3", 25,
ifelse(point.count[, 2] == "Original_y25_4", 25,
ifelse(point.count[, 2] == "Church_y15_3", 15,
ifelse(point.count[, 2] == "Church_y15_2", 15,
ifelse(point.count[, 2] == "Triangle_y15_2", 15,
ifelse(point.count[, 2] == "Triangle_y15_1", 15,
ifelse(point.count[, 2] == "Triangle_y7_2", 7,
ifelse(point.count[, 2] == "Triangle_y7_1", 7,
ifelse(point.count[, 2] == "Fox_Den_y7_2", 7,
ifelse(point.count[, 2] == "Fox_Den_y5_1", 5,
ifelse(point.count[, 2] == "Fox_Den_y5_2", 5,
ifelse(point.count[, 2] == "Fox_Den_y5_3", 5,
ifelse(point.count[, 2] == "Fox_Den_y3_1", 3,
ifelse(point.count[, 2] == "Fox_Den_y3_2", 3,
ifelse(point.count[, 2] == "Fox_Den_y3_3", 3,
ifelse(point.count[, 2] == "Fox_Den_y3_4", 3,
ifelse(point.count[, 2] == "Mowed_y0_3", 0,
ifelse(point.count[, 2] == "Mowed_y0_4", 0,
ifelse(point.count[, 2] == "Fox_Den_y0_1", 0,NA)))))))))))))))))))))
# Create a column called category based on the age of tree, which will be used as the block for analysis
point.count$category <-
ifelse(
point.count[, 2] == "Original_y25_1",
"y25",
ifelse(
point.count[, 2] == "Original_y25_2",
"y25",
ifelse(
point.count[, 2] == "Original_y25_3",
"y25",
ifelse(
point.count[, 2] == "Original_y25_4",
"y25",
ifelse(
point.count[, 2] == "Church_y15_3",
"y15",
ifelse(
point.count[, 2] == "Church_y15_2",
"y15",
ifelse(
point.count[, 2] == "Triangle_y15_2",
"y15",
ifelse(
point.count[, 2] == "Triangle_y15_1",
"y15",
ifelse(
point.count[, 2] == "Triangle_y7_2",
"y7",
ifelse(
point.count[, 2] == "Triangle_y7_1",
"y7",
ifelse(
point.count[, 2] == "Fox_Den_y7_2",
"y7",
ifelse(
point.count[, 2] == "Fox_Den_y5_1",
"y5",
ifelse(
point.count[, 2] == "Fox_Den_y5_2",
"y5",
ifelse(
point.count[, 2] == "Fox_Den_y5_3",
"y5",
ifelse(
point.count[, 2] == "Fox_Den_y3_1",
"y3",
ifelse(
point.count[, 2] == "Fox_Den_y3_2",
"y3",
ifelse(
point.count[, 2] == "Fox_Den_y3_3",
"y3",
ifelse(
point.count[, 2] == "Fox_Den_y3_4",
"y3",
ifelse(
point.count[, 2] == "Mowed_y0_3",
"y0",
ifelse(
point.count[, 2] == "Mowed_y0_4",
"y0",
ifelse(
point.count[, 2] == "Fox_Den_y0_1",
"y0",
ifelse(
point.count[, 2] == "Forest_Interior_1",
"mature",
ifelse(
point.count[, 2] == "Forest_Interior_2",
"mature",
ifelse(
point.count[, 2] == "Forest_Interior_3",
"mature",
ifelse(
point.count[, 2] == "Forest_Edge_1",
"edge",
ifelse(
point.count[, 2] == "Forest_Edge_2",
"edge",
ifelse(point.count[, 2] == "Forest_Edge_3", "edge",
NA  )))))))))))))))))))))))))))
# Note for Don: str(foo) displays a compact form of the object
str(point.count)
# Create a column with month data
point.count$date.char <- as.character(point.count$DATE)
point.count$date.char.sub <- substr(point.count$date.char, 0, 2)
point.count$month <- ifelse(
point.count$date.char.sub == "9/",
"September",
ifelse(
point.count$date.char.sub == "10",
"October",
ifelse(point.count$date.char.sub == "11", "November",
NA)
)
)
point.count$date.char <- NULL
point.count$date.char.sub <- NULL
# Combine all 0-11 m and 11-25m observations to make a better half normal function and even distance breaks
point.count$dist.band.num <- ifelse(point.count$Distance.Band == "0-10 m", "1",
ifelse(point.count$Distance.Band == "11-25 m", "1",
ifelse(point.count$Distance.Band == "25-50 m", "2",
ifelse(point.count$Distance.Band == ">50 m", "3",
ifelse(point.count$Distance.Band == "FO", "4",
NA)))))
# Create another column with month and category as a unique identifier
point.count$block_id <- paste(point.count$category, point.count$month, sep='_')
# create one more category to identify unique surveys
point.count$survey_id <- paste(point.count$Point.Name, point.count$DATE, sep='_')
# Make a data frame with the covariates and de-duplicate
det.covs <- point.count[,c(4:8,23:25,27:28)]
det.covs <- det.covs[!duplicated(det.covs), ]
#melt count data
data.count.melt <- melt(point.count, id=c("survey_id", "dist.band.num","block_id","month","category","age","Distance.Band","Species.Code","Point.Name","DATE"), measure=c("Total.Count"), na.rm=FALSE)
###Cast count data using the sum of all sparrows seen
# todo: Use species variable instead of string literal
count.data <- dcast(data.count.melt, survey_id ~ dist.band.num, fun.aggregate=sum, subset = .((Species.Code == "AMRO" ))) # | (Species.Code=="AMRO" ) | (Species.Code=="VEER") | (Species.Code=="SWTH") | (Species.Code=="WOTH") | (Species.Code=="EABL"))) # | (Species.Code=="SAVS") | (Species.Code=="SWSP") | (Species.Code=="FOSP")))
###Cast count data using the sum of all sparrows seen
# todo: Use species variable instead of string literal
count.data <- dcast(data.count.melt, survey_id ~ dist.band.num, fun.aggregate=sum, subset = .((Species.Code == "AMRO" ))) # | (Species.Code=="AMRO" ) | (Species.Code=="VEER") | (Species.Code=="SWTH") | (Species.Code=="WOTH") | (Species.Code=="EABL"))) # | (Species.Code=="SAVS") | (Species.Code=="SWSP") | (Species.Code=="FOSP")))
###Cast count data using the sum of all sparrows seen
# todo: Use species variable instead of string literal
count.data <- dcast(data.count.melt, survey_id ~ dist.band.num, fun.aggregate=sum, subset = .(Species.Code == "AMRO" )) # | (Species.Code=="AMRO" ) | (Species.Code=="VEER") | (Species.Code=="SWTH") | (Species.Code=="WOTH") | (Species.Code=="EABL"))) # | (Species.Code=="SAVS") | (Species.Code=="SWSP") | (Species.Code=="FOSP")))
View(point.count)
###Cast count data using the sum of all sparrows seen
# todo: Use species variable instead of string literal
# Dcast reference: https://www.computerworld.com/article/2486425/business-intelligence/business-intelligence-4-data-wrangling-tasks-in-r-for-advanced-beginners.html?page=8
count.data <- dcast(data.count.melt, survey_id ~ dist.band.num, sum, subset = .(Species.Code == "AMRO" )) # | (Species.Code=="AMRO" ) | (Species.Code=="VEER") | (Species.Code=="SWTH") | (Species.Code=="WOTH") | (Species.Code=="EABL"))) # | (Species.Code=="SAVS") | (Species.Code=="SWSP") | (Species.Code=="FOSP")))
library(plyr)
###Cast count data using the sum of all sparrows seen
# todo: Use species variable instead of string literal
# Dcast reference: https://www.computerworld.com/article/2486425/business-intelligence/business-intelligence-4-data-wrangling-tasks-in-r-for-advanced-beginners.html?page=8
# Reshape2 https://cran.r-project.org/web/packages/reshape2/reshape2.pdf
count.data <- dcast(data.count.melt, survey_id ~ dist.band.num, sum, subset = .(Species.Code == "AMRO" )) # | (Species.Code=="AMRO" ) | (Species.Code=="VEER") | (Species.Code=="SWTH") | (Species.Code=="WOTH") | (Species.Code=="EABL"))) # | (Species.Code=="SAVS") | (Species.Code=="SWSP") | (Species.Code=="FOSP")))
###Cast count data using the sum of all sparrows seen
# todo: Use species variable instead of string literal
# Dcast reference: https://www.computerworld.com/article/2486425/business-intelligence/business-intelligence-4-data-wrangling-tasks-in-r-for-advanced-beginners.html?page=8
# Reshape2 https://cran.r-project.org/web/packages/reshape2/reshape2.pdf
count.data <- dcast(data.count.melt, survey_id ~ dist.band.num, fun.aggregate=sum, subset = .(Species.Code == "AMRO" )) # | (Species.Code=="AMRO" ) | (Species.Code=="VEER") | (Species.Code=="SWTH") | (Species.Code=="WOTH") | (Species.Code=="EABL"))) # | (Species.Code=="SAVS") | (Species.Code=="SWSP") | (Species.Code=="FOSP")))
View(count.data)
# todo: why do we do this again?
count.data[,4:5] <- NULL
###Cast count data using the sum of all sparrows seen
# todo: Use species variable instead of string literal
# Dcast reference: https://www.computerworld.com/article/2486425/business-intelligence/business-intelligence-4-data-wrangling-tasks-in-r-for-advanced-beginners.html?page=8
# Reshape2 https://cran.r-project.org/web/packages/reshape2/reshape2.pdf
count.data <- dcast(data.count.melt, survey_id ~ dist.band.num, sum, subset = .(Species.Code == "AMRO" )) # | (Species.Code=="AMRO" ) | (Species.Code=="VEER") | (Species.Code=="SWTH") | (Species.Code=="WOTH") | (Species.Code=="EABL"))) # | (Species.Code=="SAVS") | (Species.Code=="SWSP") | (Species.Code=="FOSP")))
# todo: why do we do this again?
count.data[,4:5] <- NULL
# Remove all variables from the environment. ls() lists variables, rm() removes variables.
# This won't remove variables beginning with '.', use rm(list = ls(all.names = TRUE)) for that.
rm(list = ls(all.names = TRUE))
# Missing packages can be installed using install.packages("<package>") in the R Console.
library(unmarked)
library(reshape2)
library(ggplot2)
library(plyr)
setwd("~/projects/AMRO")
# Analysis will be performed on each of these species codes via for loop
species.codes <- c("AMRO", "EABL", "SAVS", "SWSP", "FOSP");
# This for loop is an example for Tim
for(species in species.codes) {
cat(species, "\n")
}
# This function is an example for Tim
println <- function(string) {
cat(string, "\n")
}
println(species)
point.count <- read.csv('PC_DATA_16.csv', header=TRUE)
# Get rid of surveys from points with no planting or no maintenance due to not enough survey points
# Note for Don: in R, & is a vectorized operator. &&  form evaluates left to right examining only the first element of each vector.
point.count <- subset(point.count, point.count[,2] != "Maintenance_No_Planting"  & point.count[,2] != "No_Planting_No_Maintenance", drop=T)
# Create a column for age value and fill it
point.count$age <-
ifelse(point.count[, 2] == "Original_y25_1", 25,
ifelse(point.count[, 2] == "Original_y25_2", 25,
ifelse(point.count[, 2] == "Original_y25_3", 25,
ifelse(point.count[, 2] == "Original_y25_4", 25,
ifelse(point.count[, 2] == "Church_y15_3", 15,
ifelse(point.count[, 2] == "Church_y15_2", 15,
ifelse(point.count[, 2] == "Triangle_y15_2", 15,
ifelse(point.count[, 2] == "Triangle_y15_1", 15,
ifelse(point.count[, 2] == "Triangle_y7_2", 7,
ifelse(point.count[, 2] == "Triangle_y7_1", 7,
ifelse(point.count[, 2] == "Fox_Den_y7_2", 7,
ifelse(point.count[, 2] == "Fox_Den_y5_1", 5,
ifelse(point.count[, 2] == "Fox_Den_y5_2", 5,
ifelse(point.count[, 2] == "Fox_Den_y5_3", 5,
ifelse(point.count[, 2] == "Fox_Den_y3_1", 3,
ifelse(point.count[, 2] == "Fox_Den_y3_2", 3,
ifelse(point.count[, 2] == "Fox_Den_y3_3", 3,
ifelse(point.count[, 2] == "Fox_Den_y3_4", 3,
ifelse(point.count[, 2] == "Mowed_y0_3", 0,
ifelse(point.count[, 2] == "Mowed_y0_4", 0,
ifelse(point.count[, 2] == "Fox_Den_y0_1", 0,NA)))))))))))))))))))))
# Create a column called category based on the age of tree, which will be used as the block for analysis
point.count$category <-
ifelse(
point.count[, 2] == "Original_y25_1",
"y25",
ifelse(
point.count[, 2] == "Original_y25_2",
"y25",
ifelse(
point.count[, 2] == "Original_y25_3",
"y25",
ifelse(
point.count[, 2] == "Original_y25_4",
"y25",
ifelse(
point.count[, 2] == "Church_y15_3",
"y15",
ifelse(
point.count[, 2] == "Church_y15_2",
"y15",
ifelse(
point.count[, 2] == "Triangle_y15_2",
"y15",
ifelse(
point.count[, 2] == "Triangle_y15_1",
"y15",
ifelse(
point.count[, 2] == "Triangle_y7_2",
"y7",
ifelse(
point.count[, 2] == "Triangle_y7_1",
"y7",
ifelse(
point.count[, 2] == "Fox_Den_y7_2",
"y7",
ifelse(
point.count[, 2] == "Fox_Den_y5_1",
"y5",
ifelse(
point.count[, 2] == "Fox_Den_y5_2",
"y5",
ifelse(
point.count[, 2] == "Fox_Den_y5_3",
"y5",
ifelse(
point.count[, 2] == "Fox_Den_y3_1",
"y3",
ifelse(
point.count[, 2] == "Fox_Den_y3_2",
"y3",
ifelse(
point.count[, 2] == "Fox_Den_y3_3",
"y3",
ifelse(
point.count[, 2] == "Fox_Den_y3_4",
"y3",
ifelse(
point.count[, 2] == "Mowed_y0_3",
"y0",
ifelse(
point.count[, 2] == "Mowed_y0_4",
"y0",
ifelse(
point.count[, 2] == "Fox_Den_y0_1",
"y0",
ifelse(
point.count[, 2] == "Forest_Interior_1",
"mature",
ifelse(
point.count[, 2] == "Forest_Interior_2",
"mature",
ifelse(
point.count[, 2] == "Forest_Interior_3",
"mature",
ifelse(
point.count[, 2] == "Forest_Edge_1",
"edge",
ifelse(
point.count[, 2] == "Forest_Edge_2",
"edge",
ifelse(point.count[, 2] == "Forest_Edge_3", "edge",
NA  )))))))))))))))))))))))))))
# Note for Don: str(foo) displays a compact form of the object
str(point.count)
# Create a column with month data
point.count$date.char <- as.character(point.count$DATE)
point.count$date.char.sub <- substr(point.count$date.char, 0, 2)
point.count$month <- ifelse(
point.count$date.char.sub == "9/",
"September",
ifelse(
point.count$date.char.sub == "10",
"October",
ifelse(point.count$date.char.sub == "11", "November",
NA)
)
)
point.count$date.char <- NULL
point.count$date.char.sub <- NULL
# Combine all 0-11 m and 11-25m observations to make a better half normal function and even distance breaks
point.count$dist.band.num <- ifelse(point.count$Distance.Band == "0-10 m", "1",
ifelse(point.count$Distance.Band == "11-25 m", "1",
ifelse(point.count$Distance.Band == "25-50 m", "2",
ifelse(point.count$Distance.Band == ">50 m", "3",
ifelse(point.count$Distance.Band == "FO", "4",
NA)))))
# Create another column with month and category as a unique identifier
point.count$block_id <- paste(point.count$category, point.count$month, sep='_')
# create one more category to identify unique surveys
point.count$survey_id <- paste(point.count$Point.Name, point.count$DATE, sep='_')
# Make a data frame with the covariates and de-duplicate
# todo: we never reference this variable again
det.covs <- point.count[,c(4:8,23:25,27:28)]
det.covs <- det.covs[!duplicated(det.covs), ]
#melt count data
data.count.melt <- melt(point.count, id=c("survey_id", "dist.band.num","block_id","month","category","age","Distance.Band","Species.Code","Point.Name","DATE"), measure=c("Total.Count"), na.rm=FALSE)
View(data.count.melt)
View(point.count)
View(data.count.melt)
###Cast count data using the sum of all sparrows seen
# todo: Use species variable instead of string literal
# Dcast reference: https://www.computerworld.com/article/2486425/business-intelligence/business-intelligence-4-data-wrangling-tasks-in-r-for-advanced-beginners.html?page=8
# Reshape2 https://cran.r-project.org/web/packages/reshape2/reshape2.pdf
count.data <- dcast(data.count.melt, survey_id ~ dist.band.num, sum, subset = .(Species.Code == "AMRO" )) # | (Species.Code=="AMRO" ) | (Species.Code=="VEER") | (Species.Code=="SWTH") | (Species.Code=="WOTH") | (Species.Code=="EABL"))) # | (Species.Code=="SAVS") | (Species.Code=="SWSP") | (Species.Code=="FOSP")))
View(count.data)
# todo: why do we do this again?
count.data[,4:5] <- NULL
# todo: why do we do this again?
count.data[,4] <- NULL
View(count.data)
# todo: why do we do this again?
count.data[,4:5] <- NULL
# todo: why do we do this again?
count.data <- count.data[, -c(4:5)]
# todo: why do we do this again?
count.data <- count.data[, -c(4:5)]
View(count.data)
all.birds <- merge(det.covs, count.data, by= "survey_id", all=T)
all.birds[is.na(all.birds)] <- 0
all.birds.y0.September <- subset(all.birds, all.birds$block_id == "y0_September")
all.birds.y0.October <- subset(all.birds, all.birds$block_id == "y0_October")
all.birds.y0.November <- subset(all.birds, all.birds$block_id == "y0_November")
all.birds.y3.September <- subset(all.birds, all.birds$block_id == "y3_September")
all.birds.y3.October <- subset(all.birds, all.birds$block_id == "y3_October")
all.birds.y3.November <- subset(all.birds, all.birds$block_id == "y3_November")
all.birds.y5.September <- subset(all.birds, all.birds$block_id == "y5_September")
all.birds.y5.October <- subset(all.birds, all.birds$block_id == "y5_October")
all.birds.y5.November <- subset(all.birds, all.birds$block_id == "y5_November")
all.birds.y7.September <- subset(all.birds, all.birds$block_id == "y7_September")
all.birds.y7.October <- subset(all.birds, all.birds$block_id == "y7_October")
all.birds.y7.November <- subset(all.birds, all.birds$block_id == "y7_November")
all.birds.y15.September <- subset(all.birds, all.birds$block_id == "y15_September")
all.birds.y15.October <- subset(all.birds, all.birds$block_id == "y15_October")
all.birds.y15.November <- subset(all.birds, all.birds$block_id == "y15_November")
all.birds.y25.September <- subset(all.birds, all.birds$block_id == "y25_September")
all.birds.y25.October <- subset(all.birds, all.birds$block_id == "y25_October")
all.birds.y25.November <- subset(all.birds, all.birds$block_id == "y25_November")
all.birds.y25.September <- subset(all.birds, all.birds$block_id == "y25_September")
all.birds.y25.October <- subset(all.birds, all.birds$block_id == "y25_October")
all.birds.y25.November <- subset(all.birds, all.birds$block_id == "y25_November")
all.birds.edge.September <- subset(all.birds, all.birds$block_id == "edge_September")
all.birds.edge.October <- subset(all.birds, all.birds$block_id == "edge_October")
all.birds.edge.November <- subset(all.birds, all.birds$block_id == "edge_November")
all.birds.mature.September <- subset(all.birds, all.birds$block_id == "mature_September")
all.birds.mature.October <- subset(all.birds, all.birds$block_id == "mature_October")
View(all.birds.edge.November)
all.birds.y0.September.umf <- unmarkedFrameDS(y=as.matrix(all.birds.y0.September[,11:12]),
siteCovs=data.frame(all.birds.y0.September[,3:10]),
dist.breaks=c(0,25,50), unitsIn="m", survey="point")
(fm1.all.birds.y0.September <- distsamp(~1 ~1, all.birds.y0.September.umf))
density.estimate <- predict(fm1.all.birds.y0.September, type="state", appendData=TRUE)
View(density.estimate)
cat(’point 1 mem’, memory.size(), memory.size(max=TRUE), ’\n’)
cat('point 1 mem', memory.size(), memory.size(max=TRUE), ’\n’)
cat('point 1 mem', memory.size(), memory.size(max=TRUE), '\n')
rm(ls())
rm(list=ls(all.names = TRUE))
search()
